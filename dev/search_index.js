var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ThorinDistributions","category":"page"},{"location":"#ThorinDistributions","page":"Home","title":"ThorinDistributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A gamma distribution is a distribution with pdf","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x) = fracx^α-1e^-xθΓ(α)θ^α","category":"page"},{"location":"","page":"Home","title":"Home","text":"As Bondesson shows, based on Thorin work, the class of (weak limit of) independent convolutions of gamma distributions is quite large, closed with respect to independent addition and multiplication of random variables, and contains many interesting distributions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We implement here a multivariate extensions of these results, and statistical estimation routines to allow for estimation of these distributions through a Laguerre expensions of their densities. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ThorinDistributions]","category":"page"},{"location":"#ThorinDistributions.MultivariateGamma","page":"Home","title":"ThorinDistributions.MultivariateGamma","text":"MultivariateGamma(α,θ)\n\nConstruct a distribution that correspond to several comonotonous gammas with common shapes α and respectives scales θ[i]. The distribution can then be used through several methods, following the Distributions.jl standard, mainly to obtain samples.\n\nThe code is type stable and handles any <:Real types, given by the parameters.\n\nNote that the supprot of this distribution is a half-line in the d-dimensional space, [0,+∞], with angle given by θ.\n\nExamples\n\njulia> dist = MultivariateGamma(2,[3,4,5]);\njulia> sample = zeros(Float64,(3,10));\njulia> Random.rand!(dist,sample);\n\n\n\n\n\n","category":"type"},{"location":"#ThorinDistributions.MultivariateGammaConvolution","page":"Home","title":"ThorinDistributions.MultivariateGammaConvolution","text":"MultivariateGammaConvolution(α,θ)\n\nConstructs a distribution that corresponds to the convolutions of MutlivariateGamma(α[i],θ[i,:]) distributions. The distribution can then be used through several methods, following the Distributions.jl standard\n\nThe pdf and cdf and not yet coded. The code is type stable and handles any <:Real types, given by the parameters.\n\nFitting th edistribution is not yet possible.\n\nExamples\n\njulia> dist = MultivariateGammaConvolution([2,3,1],[3 0;4 0;0 1]);\njulia> sample = zeros(Float64,(2,10));\njulia> Random.rand!(dist,sample);\n\n\n\n\n\n\n","category":"type"},{"location":"#ThorinDistributions.UnivariateGammaConvolution","page":"Home","title":"ThorinDistributions.UnivariateGammaConvolution","text":"UnivariateGammaConvolution(α,θ)\n\nConstructs a distribution that corresponds to the convolutions of Gamma(α[i],θ[i]) distributions. The distribution can then be used through several methods, following the Distributions.jl standard, to obtain pdf, cdf, random samples...\n\nThe pdf and cdf are handled by the Moshopoulos algorithm, and random samples by simply adding random gammas. The code is type stable and handles any <:Real types, given by the parameters.\n\nTo fit the distribution, a loglikelyhood approach could be used. A more involved approach from Furman might be coded sometimes (but requires tanh-sinh integration and bigfloats...)\n\nExamples\n\njulia> dist = UnivariateGammaConvolution([1,0.5, 3.7],[4,2, 10]);\njulia> sample = zeros(Float64,10);\njulia> Random.rand!(dist,sample);\njulia> pdf.((dist,),sample);\n\n\n\n\n\n","category":"type"},{"location":"#Distributions.product_distribution-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:ThorinDistributions.UnivariateGammaConvolution}","page":"Home","title":"Distributions.product_distribution","text":"Distributions.product_distribution(d1,d2)\n\nImplements the special case of the product of two gamma or univariate gamma convolutions distributions, and output as the result a multivariate gamma convolution with independent margins.\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.E_from_g-Tuple{Any}","page":"Home","title":"ThorinDistributions.E_from_g","text":"E_from_g(g)\n\nSimply computes the empirical laguerre coefficients from the exponentially shifted moments,  if you computed those moments from a theoretical distribution.\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.L2Objective-Tuple{Any, Any}","page":"Home","title":"ThorinDistributions.L2Objective","text":"L2Objective(par,emp_coefs)\n\nA L2 distance to be minimized between laguerre coefficients of MultivariateGammaConvolutions and empirical laguerre coefficients. This distance is some kind of very high degree polynomial * exponentials, so minimizing it is very hard. We recomand using some global minimisation routine, we found the Particle Swarm optimizers from Optim.jl particularly efficient.\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.MFK_Projection-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T","page":"Home","title":"ThorinDistributions.MFK_Projection","text":"MFK_Projection(g_integrals,n_gammas)\n\nFrom a set of gintegrals computed by the computeg function, this function runs the algorithm from Miles, Furman & Kuznetsov  to produce a univariate gamma convolution. \n\nThis algorithm works only if the distribution you computed the g_integrals from is, indeed, a generalized gamma convolution.  otherwise, it might fail and return garbage. \n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.compute_g-Tuple{Any, Any, Any}","page":"Home","title":"ThorinDistributions.compute_g","text":"compute_g(dist,n, integrator)\n\nThis function will compute the n first theretical (-1)-exponentially shifted moments of a distribution,  using takashi-mori tanh-sinh exponentials formulas from the DoubleExponentialFormulas package. \n\nThis might take a long time. As an integrator, you should pass the result of QuadDE(BigFloat) after setting enough precision.\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.empirical_coefs-Tuple{Any, Any}","page":"Home","title":"ThorinDistributions.empirical_coefs","text":"empirical_coefs(x,maxp)\n\nEfficiently Compute the empirical laguerre coefficients of the density of the random vector x, given as a Matrix with n row (number of samples) and d columns (number of dimensions)\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.get_coefficients-Tuple{Any, Any, Any}","page":"Home","title":"ThorinDistributions.get_coefficients","text":"get_coefficients(α,θ,m)\n\nα should be a vector of shapes of length n, θ should be a matrix of θ of size (n,d) for a MultivariateGammaConvolution with d marginals.\n\nThis function produce the coefficients of the multivariate (tensorised) expensions of the density. It is type stable and quite optimized. it is based on some precomputations that are done in a certain precision.\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.get_precomp-Union{Tuple{T}, Tuple{DataType, T}} where T<:Int64","page":"Home","title":"ThorinDistributions.get_precomp","text":"get_precomp(type,m)\n\nQuery and eventualy compute and store the precomputations for laguerre things.\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.laguerre_L_2x-Tuple{Any, Any}","page":"Home","title":"ThorinDistributions.laguerre_L_2x","text":"laguerre_L_2x(x,p)\n\nCompute univariate laguerre polynomials Lₚ(2x).\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.laguerre_density-Tuple{Any, Any}","page":"Home","title":"ThorinDistributions.laguerre_density","text":"laguerre_density(x,coefs)\n\nGiven some laguerre coefficients, computes the correpsonding function at the point x.\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.laguerre_phi-Tuple{Any, Any}","page":"Home","title":"ThorinDistributions.laguerre_phi","text":"laguerre_phi(x,p)\n\nComputes the function ϕₚ(x) = √2 e⁻ˣ Lₚ(2x). This functions form an orthonormal basis of R₊\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.laguerre_phi_several_pts-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T<:Real","page":"Home","title":"ThorinDistributions.laguerre_phi_several_pts","text":"laguerre_phi_several_pts(x,max_p)\n\nComputes the laguerrephi for each row of x and each p in CartesianIndex(maxp) This is a lot more efficient than broadcasting the laguerrephi function, but this is ugly in the sense that we re-wrote some of the code. This machanisme could be re-written more efficiently.\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.resemps_thorin_moments-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}, Any, Any}} where T","page":"Home","title":"ThorinDistributions.resemps_thorin_moments","text":"resempsthorinmoments(M,D,t_star,m)\n\nM is an integer D is the data, as a (d,n)-shaped matrix, where d is the numebr of dimensions and n the number of samples. t_star is usually taking to be -1 m is an integer.\n\nThis resamples the bare thorin moments M times, more efficienty than a simple bootstrap of the thorin_moments(D,t_star,m) function.\n\n\n\n\n\n","category":"method"},{"location":"#ThorinDistributions.thorin_moments-Union{Tuple{T}, Tuple{Vector{T}, Any, Any}} where T","page":"Home","title":"ThorinDistributions.thorin_moments","text":"thorin_moments(D,t_star,m)\n\nD should be a vector of samples from a distribution, t_star is usually taking to be -1, and m is an integer.\n\nThis compute the bare thorin moments, defined as a rescaling of the sample biaised t_star-shifted cumulants.\n\n\n\n\n\n","category":"method"}]
}
